/*
 * Copyright 2019 Roman Fatnev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.therealmone.tdf4j.generator.impl;

import io.github.therealmone.tdf4j.commons.Dependency;
import io.github.therealmone.tdf4j.commons.Module;
import io.github.therealmone.tdf4j.commons.model.ebnf.NonTerminal;
import io.github.therealmone.tdf4j.commons.model.ebnf.Production;
import io.github.therealmone.tdf4j.commons.utils.Predictor;
import io.github.therealmone.tdf4j.generator.Generator;
import io.github.therealmone.tdf4j.generator.Template;
import io.github.therealmone.tdf4j.generator.templates.ImmutableMethodTemplate;
import io.github.therealmone.tdf4j.generator.templates.MethodTemplate;
import io.github.therealmone.tdf4j.generator.templates.ParserTemplate;
import io.github.therealmone.tdf4j.generator.templates.logic.CodeBlock;
import io.github.therealmone.tdf4j.parser.MetaInf;
import io.github.therealmone.tdf4j.parser.Parser;
import io.github.therealmone.tdf4j.parser.config.AbstractParserModule;
import org.joor.Reflect;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;


public class ParserGenerator implements Generator<Parser> {

    @Override
    public Parser generate(Module module) {
        if(!(module instanceof AbstractParserModule)) {
            throw new RuntimeException("Parser can be generated only from AbstractParserModule");
        }
        return process(((AbstractParserModule) module).build());
    }

    private Parser process(final AbstractParserModule module) {
        final String generatedClassName = "AutoGeneratedParserFrom_" + module.getClass().getName().replaceFirst(module.getClass().getPackage().getName() + ".", "");
        final ParserTemplate parser = build(module, generatedClassName, module.getClass().getPackage().getName());
        return Reflect.compile(module.getClass().getPackage().getName() + "." + generatedClassName,
                parser.build()
        ).create(args(
                collectMetaInformation(parser),
                new Predictor(module.getGrammar().firstSet(), module.getGrammar().followSet()),
                module.getEnvironment().dependencies()
        )).get();
    }

    private ParserTemplate build(final AbstractParserModule module, final String className, final String pack) {
        final ParserTemplate.Builder parserBuilder = new ParserTemplate.Builder()
                .className(className)
                .pack(pack)
                .environment(module.getEnvironment())
                .imports(Template.IMPORTS.template().render());
        if(module.getGrammar().initProduction() == null) {
            throw new RuntimeException("Initial production is null");
        }
        //noinspection ConstantConditions
        parserBuilder.initProd(module.getGrammar().initProduction());
        parserBuilder.addAllMethods(collectMethods(module.getGrammar().productions()));
        return parserBuilder.build();
    }

    private List<MethodTemplate> collectMethods(final List<Production> productions) {
        final Map<NonTerminal, MethodTemplate.Builder> declaredMethods = new HashMap<>();
        for (final Production production : productions) {
            if(!declaredMethods.containsKey(production.identifier())) {
                declaredMethods.put(production.identifier(), new MethodTemplate.Builder()
                        .name(production.identifier().identifier())
                );
            }

            final MethodTemplate.Builder builder = declaredMethods.get(production.identifier());
            production.elements().forEach(element -> {
                final CodeBlock codeBlock = CodeBlock.fromElement(element);
                if(codeBlock != null) {
                    builder.addCodeBlocks(codeBlock);
                }
            });
        }
        return declaredMethods.values().stream().map((Function<MethodTemplate.Builder, MethodTemplate>) ImmutableMethodTemplate.Builder::build).collect(Collectors.toList());
    }

    private Object[] args(final MetaInf meta, final Predictor predictor, final Dependency[] dependencies) {
        final Object[] args = new Object[dependencies.length + 2];
        args[0] = meta;
        args[1] = predictor;
        for (int i = 0; i < dependencies.length; i++) {
            args[i + 2] = dependencies[i].instance();
        }
        return args;
    }

    private MetaInf collectMetaInformation(final ParserTemplate parserTemplate) {
        final MetaInf.Builder builder = new MetaInf.Builder()
                .pack(parserTemplate.pack())
                .className(parserTemplate.className())
                .sourceCode(parserTemplate.build())
                .envImports(parserTemplate.environment().packages())
                .dependencies(collectDependencies(parserTemplate))
                .imports(collectImports(parserTemplate));

        return builder.build();
    }

    private String[] collectImports(final ParserTemplate parserTemplate) {
        final List<String> imports = new ArrayList<>();
        for (String imp :parserTemplate.imports().split("\n")){
            imports.add(imp.replaceAll(";|\n|;\n|\r|;\r", ""));
        }
        return imports.toArray(new String[]{});
    }

    private String[] collectDependencies(final ParserTemplate parserTemplate) {
        final String[] dependencies = new String[parserTemplate.environment().dependencies().length];
        for (int i = 0; i < parserTemplate.environment().dependencies().length; i++) {
            final Dependency dependency = parserTemplate.environment().dependencies()[i];
            dependencies[i] = dependency.getClazz().getCanonicalName();
        }
        return dependencies;
    }
}
