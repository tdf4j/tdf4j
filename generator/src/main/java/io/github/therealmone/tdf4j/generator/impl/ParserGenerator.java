/*
 * Copyright 2019 Roman Fatnev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.therealmone.tdf4j.generator.impl;

import io.github.therealmone.tdf4j.model.Dependency;
import io.github.therealmone.tdf4j.generator.Generator;
import io.github.therealmone.tdf4j.module.parser.AbstractParserModule;
import io.github.therealmone.tdf4j.utils.Predictor;
import io.github.therealmone.tdf4j.generator.Imports;
import io.github.therealmone.tdf4j.generator.templates.ParserTemplate;
import io.github.therealmone.tdf4j.generator.MetaInfCollector;
import io.github.therealmone.tdf4j.parser.MetaInf;
import io.github.therealmone.tdf4j.parser.Parser;
import org.joor.Reflect;


public class ParserGenerator implements Generator<Parser> {
    private final MetaInfCollector metaInfCollector = new MetaInfCollector();
    private final AbstractParserModule module;

    public ParserGenerator(final AbstractParserModule module) {
        this.module = module;
    }

    @Override
    public Parser generate() {
        return process(module.build(), Parser.class);
    }

    public <T extends Parser> T generate(final Class<T> interfaceToImplement) {
        return process(module.build(), interfaceToImplement);
    }

    private <T extends Parser> T process(final AbstractParserModule module, final Class<T> interfaceToImplement) {
        final String generatedClassName = "AutoGeneratedParserFrom_" + module.getClass().getName().replaceFirst(module.getClass().getPackage().getName() + ".", "");
        final ParserTemplate parser = build(
                module,
                generatedClassName,
                module.getClass().getPackage().getName(),
                interfaceToImplement
        );
        return Reflect.compile(module.getClass().getPackage().getName() + "." + generatedClassName,
                parser.build()
        ).create(args(
                metaInfCollector.collect(parser),
                new Predictor(module.getGrammar().getFirstSet(), module.getGrammar().getFollowSet()),
                module.getEnvironment().getDependencies()
        )).get();
    }

    private ParserTemplate build(final AbstractParserModule module, final String className, final String pack, final Class<? extends Parser> interfaceToImplement) {
        final ParserTemplate.Builder parserBuilder = new ParserTemplate.Builder()
                .setClassName(className)
                .setPackage(pack)
                .setEnvironment(module.getEnvironment())
                .setImports(imports(interfaceToImplement.getCanonicalName()))
                .setInterface(interfaceToImplement.getSimpleName());
        if(module.getGrammar().getAxiom() == null) {
            throw new RuntimeException("Initial production is null");
        }
        //noinspection ConstantConditions
        parserBuilder.setGrammar(module.getGrammar());
        return parserBuilder.build();
    }

    private Object[] args(final MetaInf meta, final Predictor predictor, final Dependency[] dependencies) {
        final Object[] args = new Object[dependencies.length + 2];
        args[0] = meta;
        args[1] = predictor;
        for (int i = 0; i < dependencies.length; i++) {
            args[i + 2] = dependencies[i].instance();
        }
        return args;
    }

    private String[] imports(final String... additional) {
        final String[] imports = new String[Imports.values().length + additional.length];
        for (int i = 0; i < Imports.values().length; i++) {
            imports[i] = Imports.values()[i].getValue();
        }
        System.arraycopy(additional, 0, imports, Imports.values().length, additional.length);
        return imports;
    }
}
