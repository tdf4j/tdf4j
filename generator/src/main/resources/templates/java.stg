/*
 * Copyright Roman Fatnev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
parser(package, imports, environment, className, initProd, methods) ::= <<
package <package>;

<imports>
<environment.packages: {package| import <package>;}; separator="\n">

public class <className> implements Parser {
    private final MetaInf meta;
    private final First first;
    private final Follow follow;

    <environment.dependencies: {dependency| private final <dependency.clazz.simpleName> <dependency.name>;}; separator="\n">

    private AST ast;
    private BufferedStream\<Token> stream;

    public <className>(
        final MetaInf meta,
        final First first,
        final Follow follow<environment.dependencies: {dependency|,<\n><\t><\t>final <dependency.clazz.simpleName> <dependency.name>}>
    ) {
        this.meta = meta;
        this.first = first;
        this.follow = follow;
        <environment.dependencies: {dependency| this.<dependency.name> = <dependency.name>;}; separator="\n">
    }

    @Override
    public AST parse(final Stream\<Token> tokens) {
        this.stream = new BufferedStream\<>(tokens);
        this.ast = new AST("<initProd>");
        <initProd>();
        return ast;
    }

    @Override
    public AST parse(final List\<Token> tokens) {
        tokens.forEach(token -> {
            System.out.println(token.tag() + " : " + token.value());
        });
        return null;
    }

    @Override
    public MetaInf meta() {
        return this.meta;
    }

    <methods: {method|<method><\n><\n>}>

    private List\<String> predict(final Token token) {
        if(token == null) {
            return new ArrayList\<>();
        }
        final List\<String> predictions = new ArrayList\<>();
        first.set().forEach((ident, set) -> {
            if(set.stream().map(Terminal.Tag::value).collect(Collectors.toSet()).contains(token.tag())) {
                predictions.add(ident);
            }
        });
        predictions.add(token.tag());
        return predictions;
    }

    private boolean contains(final List\<String> predictions, final String element) {
        return predictions.contains(element);
    }

    <environment.code>
}
>>

method(returnValue, name, codeBlocks) ::= <<
private <returnValue> <name>() {
    <codeBlocks: {codeBlock|<codeBlock>};separator="\n">
}
>>

imports() ::= <<
import io.github.therealmone.tdf4j.parser.*;
import io.github.therealmone.tdf4j.parser.model.ast.*;
import io.github.therealmone.tdf4j.commons.model.ebnf.*;
import io.github.therealmone.tdf4j.commons.*;
import io.github.therealmone.tdf4j.commons.Stream;
import io.github.therealmone.tdf4j.commons.utils.*;
import java.util.*;
import java.util.stream.*;
>>

except(exceptions) ::= <<
if(stream.peek() == null ||
    <exceptions: {exception|stream.peek().tag().equalsIgnoreCase("<exception>")};separator=" ||\n">
) {
    throw new UnexpectedTokenException(stream.peek());
} else {
    ast.addLeaf(stream.next());
}
>>

ele_group(codeBlocks, hash) ::= <<
{
    <codeBlocks: {codeBlock|<codeBlock>};separator="\n">
}
>>

non_terminal(nonTerminal) ::= <<
{
    ast.addNode("<nonTerminal>")
        .moveCursor(AST.Movement.TO_LAST_ADDED_NODE);
    <nonTerminal>();
    ast.moveCursor(AST.Movement.TO_PARENT);
}
>>

optional(firstElements, codeBlocks, hash) ::= <<
{
    if(<firstElements: {firstElement|predict(stream.peek()).contains("<firstElement>")}; separator=" ||\n">) {
        <codeBlocks: {codeBlock|<codeBlock>};separator="\n">
    }
}
>>

or(firstStartElements, firstCodeBlocks, secondStartElements, secondCodeBlocks) ::= <<
{
    if(stream.peek() != null && (
        <firstStartElements: {startElement|predict(stream.peek()).contains("<startElement>")}; separator=" ||\n">
    )) {
        <firstCodeBlocks: {codeBlock|<codeBlock>};separator="\n">
    } else if(stream.peek() != null && (
        <secondStartElements: {startElement|predict(stream.peek()).contains("<startElement>")}; separator=" ||\n">
    )) {
        <secondCodeBlocks: {codeBlock|<codeBlock>};separator="\n">
    } else {
        throw new UnexpectedTokenException(stream.peek());
    }
}
>>

repeat(firstElements, codeBlocks, hash) ::= <<
{
    while(true) {
        if(<firstElements: {firstElement|predict(stream.peek()).contains("<firstElement>")}; separator=" ||\n">) {
            <codeBlocks: {codeBlock|<codeBlock>};separator="\n">
        } else {
            break;
        }
    }
}
>>

repetition(hash, times, codeBlocks) ::= <<
{
    for(int i<hash> = 0; i<hash> \< <times>; i<hash>++) {
        <codeBlocks: {codeBlock|<codeBlock>};separator="\n">
    }
}
>>

terminal_tag(terminal) ::= <<
if(stream.peek() != null && stream.peek().tag().equalsIgnoreCase("<terminal>")) {
    ast.addLeaf(stream.next());
} else {
    throw new UnexpectedTokenException(stream.peek());
}
>>

inline_action(inlineAction) ::= <<
<inlineAction>
>>

